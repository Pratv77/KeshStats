"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountManager = void 0;
const collection_1 = require("@discordjs/collection");
const structures_1 = require("../structures");
/**
 * An account manager - to fetch and manage all the RIOT accounts.
 */
class AccountManager {
    /**
     * Creates a new account manager.
     * @param client - The client this account manager belongs to.
     */
    constructor(client) {
        /**
         * The client this accounts manager belongs to.
         */
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The accounts cached in the memory.
         *
         * Only use this if you absolutely must.
         * Prioritize using
         * {@link AccountManager.fetch | fetch} or
         * {@link AccountManager.fetchByNameAndTag | fetchByNameAndTag}
         * instead.
         */
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.cache = new collection_1.Collection();
    }
    /**
     * Fetch a RIOT account by its unique PUUID.
     *
     * @param id - The PUUID of the RIOT account.
     * @param options - The basic fetching options.
     */
    async fetch(id, options) {
        const force = options?.force ?? false;
        const cache = options?.cache ?? true;
        const region = options?.region ?? this.client.region;
        return new Promise(async (resolve, reject) => {
            if (this.cache.has(id) && !force)
                resolve(this.cache.get(id));
            else {
                const accountResponse = await this.client.api
                    .makeApiRequest('/riot/account/v1/accounts/by-puuid/' + id, {
                    region,
                    regional: true,
                    name: 'Account by PUUID',
                    params: 'PUUID: ' + id
                })
                    .catch(reject);
                if (accountResponse) {
                    const accountData = accountResponse.data;
                    const account = new structures_1.Account(accountData);
                    if (cache)
                        this.cache.set(id, account);
                    resolve(account);
                }
            }
        });
    }
    /**
     * Fetch a RIOT account by its name and tag.
     *
     * @param name - The name of this RIOT account.
     * @param tag - The tag of this RIOT account.
     * @param options - The basic fetching options.
     */
    async fetchByNameAndTag(name, tag, options) {
        const force = options?.force ?? false;
        const cache = options?.cache ?? true;
        const region = options?.region ?? this.client.region;
        return new Promise(async (resolve, reject) => {
            const cached = this.cache.find((a) => a.username === name && a.userTag === tag);
            if (cached && !force)
                resolve(cached);
            const accountResponse = await this.client.api
                .makeApiRequest('/riot/account/v1/accounts/by-riot-id/' + encodeURIComponent(name) + '/' + tag, {
                region,
                regional: true,
                name: 'Account by name and tag',
                params: 'NAME: ' + name + ', TAG: ' + tag
            })
                .catch(reject);
            if (accountResponse) {
                const accountData = accountResponse.data;
                const account = new structures_1.Account(accountData);
                if (cache)
                    this.cache.set(account.playerId, account);
                resolve(account);
            }
        });
    }
}
exports.AccountManager = AccountManager;
//# sourceMappingURL=AccountManager.js.map