"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemManager = void 0;
const tslib_1 = require("tslib");
const structures_1 = require("../structures");
const collection_1 = require("@discordjs/collection");
const index_1 = require("./index");
const path_1 = tslib_1.__importDefault(require("path"));
/**
 * An item manager - to fetch and manage all item data.
 */
class ItemManager {
    /**
     * Create a new item manager.
     *
     * @param client - The client this manager belongs to.
     * @param cacheSettings - The basic caching settings.
     */
    constructor(client, cacheSettings) {
        /**
         * A collection of the items cached in the memory.
         *
         * Only use this if you absolutely must.
         * Prioritize using {@link ItemManager.fetch | fetch} instead.
         */
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The client this manager belongs to.
         */
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_itemData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.cache = new collection_1.Collection();
        if (cacheSettings.enable)
            this._itemData = new index_1.StorageManager(client, 'dDragon/items', cacheSettings.root);
    }
    async _fetchLocalItems() {
        if (this._itemData)
            this._itemData.pathName = path_1.default.join('dDragon', this.client.version, this.client.locale, 'items');
        return new Promise(async (resolve, reject) => {
            const data = this._itemData?.fetch('items');
            if (data)
                resolve(data);
            else {
                const response = await this.client.http.get(`${this.client.version}/data/${this.client.locale}/item.json`);
                if (response.status !== 200)
                    reject('Unable to fetch items from Data dragon');
                else {
                    this._itemData?.store('items', response.data.data);
                    resolve(response.data.data);
                }
            }
        });
    }
    async _fetchAll(options) {
        const cache = options?.cache ?? true;
        return new Promise(async (resolve, reject) => {
            const items = await this._fetchLocalItems().catch(reject);
            for (const key of Object.keys(items)) {
                const item = new structures_1.Item(this.client, key, items[key]);
                if (cache)
                    this.cache.set(key, item);
            }
            resolve(this.cache);
        });
    }
    /**
     * Fetch an item by its 4-digit ID. The ID must be a string of 4 digits (not a number)
     *
     * @param key - The ID of the item to fetch.
     * @param options - The basic fetching options.
     */
    async fetch(key, options) {
        const force = options?.force ?? false;
        return new Promise(async (resolve, reject) => {
            if (this.cache.has(key) && !force)
                resolve(this.cache.get(key));
            else {
                await this._fetchAll(options);
                if (this.cache.has(key))
                    resolve(this.cache.get(key));
                else
                    reject('There is no item with that ID');
            }
        });
    }
    /**
     * Find an item by its name.
     *
     * @deprecated Please use {@link ItemManager.fetchByName | fetchByName} instead.
     * @param name - The name of the item to look for.
     */
    async findByName(name) {
        return this.fetchByName(name);
    }
    /**
     * Fetch an item by its name.
     * The search is case-insensitive.
     * The special characters are NOT ignored.
     *
     * @param name - The name of the item to look for.
     * @param options - The basic fetching options.
     */
    async fetchByName(name, options) {
        const force = options?.force ?? false;
        if (!this.cache.size || force)
            await this._fetchAll(options);
        return this.cache.find((i) => i.name.toLowerCase().includes(name.toLowerCase()));
    }
}
exports.ItemManager = ItemManager;
//# sourceMappingURL=ItemManager.js.map