"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChampionMasteryManager = void 0;
const collection_1 = require("@discordjs/collection");
const structures_1 = require("../structures");
/**
 * A champion mastery manager - to fetch and manage all summoner's champion mastery data.
 */
class ChampionMasteryManager {
    /**
     * Creates a new champion mastery manager.
     *
     * @param client - The client that instantiated this manager.
     * @param summoner - The summoner this manager belongs to.
     */
    constructor(client, summoner) {
        /**
         * The cached mastery data for the summoner.
         *
         * Only use this if you absolutely must.
         * Prioritize using {@link ChampionMasteryManager.fetch | fetch} instead.
         */
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The client this manager belongs to.
         */
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The ID of the summoner whose mastery is managed by this manager.
         */
        Object.defineProperty(this, "summoner", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_totalScore", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.summoner = summoner;
        this.cache = new collection_1.Collection();
        this._totalScore = 0;
    }
    /**
     * The total mastery score of this summoner.
     */
    get totalScore() {
        return this._totalScore;
    }
    /**
     * The cached champion masteries of the summoner as a sorted array.
     *
     * The array is sorted from the highest mastery to lowest.
     * While sorting, the mastery level is prioritized over the number of points.
     */
    get sortedCache() {
        const sorted = this._sortMastery(this.cache);
        return Array.from(sorted.values());
    }
    /**
     * Fetch a champion's mastery data for the summoner.
     *
     * @param champion - The champion (or its ID) whose mastery data needs to be fetched.
     * @param options - The basic fetching options.
     */
    async fetch(champion, options) {
        const force = options?.force ?? false;
        const cache = options?.cache ?? true;
        const region = options?.region ?? this.summoner.region;
        const id = champion instanceof structures_1.Champion ? champion.id : champion;
        return new Promise(async (resolve, reject) => {
            const champ = await this.client.champions.fetch(id, options).catch(() => undefined);
            if (!champ)
                reject('Invalid champion ID');
            else if (this.cache.has(champ.id) && !force)
                resolve(this.cache.get(id));
            else {
                const response = await this.client.api
                    .makeApiRequest(`/lol/champion-mastery/v4/champion-masteries/by-summoner/${this.summoner.id}/by-champion/${champ.key}`, {
                    region,
                    regional: false,
                    name: 'Champion mastery by champion',
                    params: `Summoner ID: ${this.summoner.id}, Champion ID: ${champ.key}`
                })
                    .catch(reject);
                if (response) {
                    const data = response.data;
                    const mastery = new structures_1.ChampionMastery(this.client, data);
                    if (cache)
                        this.cache.set(champ.id, mastery);
                    resolve(mastery);
                }
            }
        });
    }
    /**
     * Get the nth highest champion mastery for the summoner.
     *
     * @param n - The ranking of the champion in the summoner's champions mastery, defaults to 0 (highest).
     * @param options - The basic fetching options.
     */
    async highest(n = 0, options) {
        const force = options?.force ?? false;
        const cache = options?.cache ?? true;
        return new Promise(async (resolve, reject) => {
            if (n < 0)
                reject('The value of `n` must be >= 0.');
            else {
                const dataList = await (this.cache.size > 0 && !force
                    ? this.cache
                    : this._fetchRawMasteryData().catch(reject));
                const ordered = this._sortMastery(dataList);
                if (ordered.at(n)) {
                    const mastery = ordered.at(n);
                    if (mastery instanceof structures_1.ChampionMastery)
                        resolve(mastery);
                    else {
                        const champ = await this.client.champions.fetchByKey(mastery.championId).catch(() => undefined);
                        if (!champ)
                            reject('Invalid champion ID');
                        else {
                            if (cache)
                                this.cache.set(champ.id, new structures_1.ChampionMastery(this.client, mastery));
                            resolve(this.cache.get(champ.id));
                        }
                    }
                }
                else
                    reject('This summoner does not have mastery points for ' + n + ' champions');
            }
        });
    }
    /**
     * @deprecated use fetchAll instead
     */
    refreshAll() {
        return this.fetchAll();
    }
    /**
     * Fetches all the champions' masteries data for this summoner and store them in the cache.
     */
    async fetchAll() {
        return new Promise(async (resolve, reject) => {
            const dataList = (await this._fetchRawMasteryData().catch(reject));
            // Fetch all champions that this summoner has any mastery points
            const cacheIds = this.client.champions.cache.map((c) => c.key);
            const championsToFetch = dataList.filter((c) => !cacheIds.includes(c.championId));
            await this.client.champions.fetchByKeys(championsToFetch.map((c) => c.championId));
            for (const data of dataList) {
                const mastery = new structures_1.ChampionMastery(this.client, data);
                this.cache.set(mastery.champion.id, mastery);
            }
            resolve(this.cache);
        });
    }
    /**
     * Get an updated total mastery score for this summoner.
     */
    async updateTotalScore() {
        return new Promise(async (resolve, reject) => {
            const response = await this.client.api
                .makeApiRequest(`/lol/champion-mastery/v4/scores/by-summoner/${this.summoner.id}`, {
                region: this.summoner.region,
                regional: false,
                name: 'Champion mastery score by summoner',
                params: `Summoner ID: ${this.summoner.id}`
            })
                .catch(reject);
            if (response) {
                const score = response.data;
                this._totalScore = score;
                resolve(score);
            }
        });
    }
    /**
     * Fetch raw ChampionMasteryData[] response from API
     */
    _fetchRawMasteryData() {
        return new Promise(async (resolve, reject) => {
            const response = await this.client.api
                .makeApiRequest(`/lol/champion-mastery/v4/champion-masteries/by-summoner/${this.summoner.id}`, {
                region: this.summoner.region,
                regional: false,
                name: 'Champion mastery by summoner',
                params: `Summoner ID: ${this.summoner.id}`
            })
                .catch(reject);
            if (response) {
                const data = response.data;
                resolve(data);
            }
        });
    }
    /**
     * Sort mastery by level and points
     * Works for raw and parsed masteries
     */
    _sortMastery(data) {
        const sorter = (a, b) => ('level' in b ? b.level : b.championLevel) - ('level' in a ? a.level : a.championLevel) ||
            ('points' in b ? b.points : b.championPoints) - ('points' in a ? a.points : a.championPoints);
        return data.sort(sorter);
    }
}
exports.ChampionMasteryManager = ChampionMasteryManager;
//# sourceMappingURL=ChampionMasteryManager.js.map