"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChampionManager = void 0;
const tslib_1 = require("tslib");
const collection_1 = require("@discordjs/collection");
const structures_1 = require("../structures");
const index_1 = require("./index");
const path_1 = tslib_1.__importDefault(require("path"));
/**
 * A champion manager - to fetch and manage all the champion data.
 */
class ChampionManager {
    /**
     * Create a new Champions Manager
     *
     * @param client - The client this manager belongs to.
     * @param cacheSettings - The basic caching settings.
     */
    constructor(client, cacheSettings) {
        /**
         * The champions cached in the memory.
         *
         * Only use this if you absolutely must.
         * Prioritize using
         * {@link ChampionManager.fetch | fetch},
         * {@link ChampionManager.fetchByKey | fetchByKey },
         * {@link ChampionManager.fetchByName | fetchByName} or
         * {@link ChampionManager.fetchAll | fetchAll}
         * instead.
         */
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The champion rotations cached in the memory.
         *
         * Only use this if you absolutely must.
         * Prioritize using
         * {@link ChampionManager.fetchRotations | fetchRotations}
         */
        Object.defineProperty(this, "rotation", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The client that this manager belongs to.
         */
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_champData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_damageData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_pricingData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.cache = new collection_1.Collection();
        this.rotation = new collection_1.Collection();
        if (cacheSettings.enable) {
            this._champData = new index_1.StorageManager(client, 'dDragon/champions', cacheSettings.root);
            this._damageData = new index_1.StorageManager(client, 'cDragon/champions', cacheSettings.root);
            this._pricingData = new index_1.StorageManager(client, 'meraki/champions', cacheSettings.root);
        }
    }
    async _fetchLocalChamp(name) {
        if (this._champData)
            this._champData.pathName = path_1.default.join('dDragon', this.client.version, this.client.locale, 'champions');
        return new Promise(async (resolve, reject) => {
            const data = this._champData?.fetch(name);
            if (data)
                resolve(data);
            else {
                const response = await this.client.http.get(`${this.client.version}/data/${this.client.locale}/champion/${name}.json`);
                if (response.status !== 200)
                    reject("Unable to fetch the champion's data");
                else {
                    this._champData?.store(name, response.data);
                    resolve(response.data);
                }
            }
        });
    }
    async _fetchLocalPricing(name) {
        if (this._pricingData)
            this._pricingData.pathName = path_1.default.join('meraki', 'champions');
        return new Promise(async (resolve, reject) => {
            const data = this._pricingData?.fetch(name);
            if (data)
                resolve(data);
            else {
                const response = await this.client.http.get(`https://cdn.merakianalytics.com/riot/lol/resources/latest/en-US/champions/${name}.json`);
                if (response.status !== 200)
                    reject("Unable to fetch the champion's pricing.");
                else {
                    this._pricingData?.store(name, response.data);
                    resolve(response.data);
                }
            }
        });
    }
    async _fetchLocalDamage(name) {
        if (this._damageData)
            this._damageData.pathName = path_1.default.join('cDragon', this.client.patch, 'champions');
        return new Promise(async (resolve, reject) => {
            const data = this._damageData?.fetch(name);
            if (data)
                resolve(data);
            else {
                const response = await this.client.http.get(`https://raw.communitydragon.org/${this.client.patch}/game/data/characters/${name.toLowerCase()}/${name.toLowerCase()}.bin.json`);
                if (response.status !== 200)
                    reject("Unable to fetch the champion's damage data");
                else {
                    this._damageData?.store(name, response.data);
                    resolve(response.data);
                }
            }
        });
    }
    /**
     * Fetch all the champions and store it in the cache.
     *
     * This always fetches freshly from data dragon and community dragon.
     *
     * @param options - The basic fetching options (only `cache` affects this method).
     */
    async fetchAll(options) {
        const cache = options?.cache ?? true;
        return new Promise(async (resolve, reject) => {
            const response = await this.client.http.get(this.client.version + '/data/' + this.client.locale + '/championFull.json');
            if (response.status !== 200)
                reject('Unable to fetch the champions data.');
            else {
                const result = new collection_1.Collection();
                const champs = response.data;
                for (const key of Object.keys(champs.data)) {
                    const champ = champs.data[key];
                    const damage = await this._fetchLocalDamage(champ.id).catch(reject);
                    const meraki = await this._fetchLocalPricing(champ.id).catch(reject);
                    const champion = new structures_1.Champion(this.client, champs.data[key], damage, meraki);
                    result.set(key, champion);
                    if (cache)
                        this.cache.set(key, champion);
                }
                resolve(result);
            }
        });
    }
    /**
     * Fetches a champion (from the cache, if already available), or from data dragon and community dragon.
     * @param id - The {@link Champion.id | ID} of the champion whose data needs to be fetched.
     * @param options - The basic fetching options.
     */
    async fetch(id, options) {
        const force = options?.force ?? false;
        const cache = options?.cache ?? true;
        if (id === 'FiddleSticks')
            id = 'Fiddlesticks'; // There is some internal inconsistency in Riot's JSON files.
        return new Promise(async (resolve, reject) => {
            if (this.cache.has(id) && !force)
                resolve(this.cache.get(id));
            else {
                const champs = await this._fetchLocalChamp(id).catch(reject);
                const key = Object.keys(champs.data)[0];
                const damage = await this._fetchLocalDamage(id).catch(reject);
                const meraki = await this._fetchLocalPricing(id).catch(reject);
                const champ = new structures_1.Champion(this.client, champs.data[key], damage, meraki);
                if (cache)
                    this.cache.set(key, champ);
                resolve(champ);
            }
        });
    }
    /**
     * Find a champion by their 3-digit key.
     *
     * @deprecated Use {@link ChampionManager.fetchByKey | fetchByKey} instead.
     * @param key - The 3-digit key of the champion to look for.
     */
    async findByKey(key) {
        return this.fetchByKey(key);
    }
    /**
     * Find a champion by their name.
     *
     * @deprecated Use {@link ChampionManager.fetchByName | fetchByName} instead.
     * @param name - The name of the champion to look for.
     */
    async findByName(name) {
        return this.fetchByName(name);
    }
    /**
     * Fetch and cache champion by their name (instead of ID, which is very similar but not the same as the name).
     * The search is case-insensitive.
     * The special characters are NOT ignored.
     *
     * @param name - The name of the champions to fetch.
     * @param options - The basic fetching options.
     */
    async fetchByName(name, options) {
        return this.fetchByNames([name], options).then((c) => c.first());
    }
    /**
     * Fetch and cache champion by their unique 3-digit keys.
     *
     * This is mostly for internal use while fetching match (or live match) data to improve performance.
     *
     * @param key - The key of the champions to fetch.
     * @param options - The basic fetching options.
     */
    async fetchByKey(key, options) {
        return this.fetchByKeys([key], options).then((c) => c.first());
    }
    /**
     * Fetch and cache champions by their names.
     *
     * @param names - The names of the champions to fetch.
     * @param options - The basic fetching options.
     */
    async fetchByNames(names, options) {
        return new Promise(async (resolve, reject) => {
            const force = options?.force ?? false;
            const cache = options?.cache ?? true;
            const result = new collection_1.Collection();
            if (!force)
                for (const name of names) {
                    const champ = this.cache.find((c) => c.name.toLowerCase().includes(name.toLowerCase()));
                    if (champ) {
                        result.set(champ.id, champ);
                        names = names.filter((n) => n !== name);
                    }
                }
            if (names.length) {
                const response = await this.client.http.get(this.client.version + '/data/' + this.client.locale + '/championFull.json');
                if (response.status !== 200)
                    reject('Unable to fetch the champions data.');
                else {
                    const champs = response.data;
                    for (const key of Object.keys(champs.data)) {
                        const champ = champs.data[key];
                        if (names.some((n) => champ.name.toLowerCase().includes(n.toLowerCase()))) {
                            const damage = await this._fetchLocalDamage(champ.id).catch(reject);
                            const meraki = await this._fetchLocalPricing(champ.id).catch(reject);
                            const champion = new structures_1.Champion(this.client, champs.data[key], damage, meraki);
                            result.set(key, champion);
                            if (cache)
                                this.cache.set(key, champion);
                        }
                    }
                    resolve(result);
                }
            }
            else
                resolve(result);
        });
    }
    /**
     * Fetch and cache champions by their unique 3-digit keys.
     *
     * This is mostly for internal use while fetching match (or live match) data to improve performance.
     * Ideally, any user would be using {@link ChampionManager.fetch | fetch}.
     *
     * @param keys - The keys of the champions to fetch.
     * @param options - The basic fetching options.
     */
    async fetchByKeys(keys, options) {
        const force = options?.force ?? false;
        const cache = options?.cache ?? true;
        return new Promise(async (resolve, reject) => {
            const result = new collection_1.Collection();
            if (!force)
                for (const key of keys) {
                    const champ = this.cache.find((c) => c.key === key);
                    if (champ) {
                        result.set(champ.id, champ);
                        keys = keys.filter((k) => k !== key);
                    }
                }
            if (keys.length) {
                const response = await this.client.http.get(this.client.version + '/data/' + this.client.locale + '/championFull.json');
                if (response.status !== 200)
                    reject('Unable to fetch the champions data.');
                else {
                    const champs = response.data;
                    for (const key of Object.keys(champs.data)) {
                        const champ = champs.data[key];
                        if (keys.some((k) => champ.key === String(k))) {
                            const damage = await this._fetchLocalDamage(champ.id).catch(reject);
                            const meraki = await this._fetchLocalPricing(champ.id).catch(reject);
                            const champion = new structures_1.Champion(this.client, champs.data[key], damage, meraki);
                            result.set(key, champion);
                            if (cache)
                                this.cache.set(key, champion);
                        }
                    }
                    resolve(result);
                }
            }
            else
                resolve(result);
        });
    }
    /**
     * Fetch champion rotation data from Champion v3 API.
     *
     * This is the only method that needs a valid API key in this manager.
     *
     * @param options - The basic fetching options.
     */
    async fetchRotations(options) {
        const force = options?.force ?? false;
        const cache = options?.cache ?? true;
        return new Promise(async (resolve, reject) => {
            if (this.rotation.get('all') && this.rotation.get('new') && !force)
                resolve(this.rotation);
            const response = await this.client.api.makeApiRequest('/lol/platform/v3/champion-rotations', {
                name: 'Champion rotation',
                params: '',
                region: this.client.region,
                regional: false
            });
            if (response.status !== 200)
                reject('Unable to fetch the champions data.');
            else {
                const result = new collection_1.Collection();
                const champs = response.data;
                const all = await this.fetchByKeys(champs.freeChampionIds.map((c) => Number(c)));
                const forNew = await this.fetchByKeys(champs.freeChampionIdsForNewPlayers.map((c) => Number(c)));
                result.set('all', all.toJSON());
                result.set('new', forNew.toJSON());
                if (cache)
                    this.rotation.set('all', all.toJSON());
                if (cache)
                    this.rotation.set('new', forNew.toJSON());
                resolve(result);
            }
        });
    }
}
exports.ChampionManager = ChampionManager;
//# sourceMappingURL=ChampionManager.js.map