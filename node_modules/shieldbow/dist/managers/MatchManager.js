"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MatchManager = void 0;
const structures_1 = require("../structures");
const collection_1 = require("@discordjs/collection");
/**
 * A match manager - to fetch and manage matches.
 */
class MatchManager {
    /**
     * Creates a new match manager.
     * @param client - The client that instantiated the manager.
     */
    constructor(client) {
        /**
         * The collection of cached matches.
         *
         * Only use this if you absolutely must.
         * Prioritize using
         * {@link MatchManager.fetch | fetch} and
         * {@link MatchManager.fetchMatchListByPlayer | fetchMatchListByPlayer}
         * instead.
         */
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The collection of cached match timelines.
         *
         * Only use this if you absolutely must.
         * Prioritize using {@link MatchManager.fetchMatchTimeline | fetchMatchTimeline} instead.
         */
        Object.defineProperty(this, "timelineCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /**
         * The client that instantiated the manager.
         */
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
        this.cache = new collection_1.Collection();
        this.timelineCache = new collection_1.Collection();
    }
    /**
     * Fetch a match by its ID.
     * @param id - The ID of the match
     * @param options - The basic fetch options
     */
    async fetch(id, options) {
        const force = options?.force ?? false;
        const cache = options?.cache ?? true;
        const region = options?.region ?? this.client.region;
        return new Promise(async (resolve, reject) => {
            if (this.cache.has(id) && !force)
                resolve(this.cache.get(id));
            else {
                const response = await this.client.api
                    .makeApiRequest(`/lol/match/v5/matches/${id}`, {
                    region,
                    regional: true,
                    name: 'Get Match By Match ID',
                    params: 'Match ID: ' + id
                })
                    .catch(reject);
                if (response)
                    try {
                        const data = response.data;
                        await this.client.champions.fetchByKeys(data.info.participants.map((p) => p.championId));
                        if (this.client.items.cache.size === 0)
                            await this.client.items.fetch('1001');
                        if (this.client.summonerSpells.cache.size === 0)
                            await this.client.summonerSpells.fetchByName('Flash');
                        if (this.client.runes.cache.size === 0)
                            await this.client.runes.fetch('Domination');
                        const match = new structures_1.Match(this.client, data);
                        if (cache)
                            this.cache.set(id, match);
                        resolve(match);
                    }
                    catch (e) {
                        reject(e);
                    }
            }
        });
    }
    /**
     * Fetch a match timeline by the match ID.
     *
     * @param matchId - The ID of the match
     * @param options - The basic fetch options
     */
    async fetchMatchTimeline(matchId, options) {
        const force = options?.force ?? false;
        const cache = options?.cache ?? true;
        const region = options?.region ?? this.client.region;
        return new Promise(async (resolve, reject) => {
            if (this.timelineCache.has(matchId) && !force)
                resolve(this.timelineCache.get(matchId));
            else {
                const response = await this.client.api
                    .makeApiRequest(`/lol/match/v5/matches/${matchId}/timeline`, {
                    region,
                    regional: true,
                    name: 'Get Match Timeline By Match ID',
                    params: 'Match ID: ' + matchId
                })
                    .catch(reject);
                if (response) {
                    const data = response.data;
                    const timeline = new structures_1.MatchTimeline(this.client, data);
                    if (cache)
                        this.timelineCache.set(matchId, timeline);
                    resolve(timeline);
                }
            }
        });
    }
    /**
     * Fetch a list of match IDs by a player ID.
     *
     * @param player - The summoner or their player ID whose matches need to be fetched.
     * @param options - The options for filtering the matches.
     */
    async fetchMatchListByPlayer(player, options) {
        return new Promise(async (resolve, reject) => {
            const playerId = typeof player === 'string' ? player : player.playerId;
            const region = typeof player === 'string' ? this.client.region : player.region;
            // The base is not used here, it is only there to prevent INVALID URL errors.
            const url = new URL('/lol/match/v5/matches/by-puuid/' + playerId + '/ids', 'https://na1.api.riotgames.com');
            if (options?.startTime)
                url.searchParams.set('startTime', options.startTime.toString());
            if (options?.endTime)
                url.searchParams.set('endTime', options.endTime.toString());
            if (options?.queue)
                url.searchParams.set('queue', options.queue.toString());
            if (options?.type)
                url.searchParams.set('type', options.type);
            if (options?.start)
                url.searchParams.set('start', options.start.toString());
            if (options?.count)
                url.searchParams.set('count', options.count.toString());
            const response = await this.client.api
                .makeApiRequest(url.pathname + url.search, {
                region,
                regional: true,
                name: 'Get Match List By Player ID',
                params: 'Player ID: ' + playerId
            })
                .catch(reject);
            if (response) {
                const data = response.data;
                resolve(data);
            }
        });
    }
}
exports.MatchManager = MatchManager;
//# sourceMappingURL=MatchManager.js.map