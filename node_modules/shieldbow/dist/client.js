"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const managers_1 = require("./managers");
const api_1 = require("./api");
const patchRegex = /\d+\.\d+/;
/**
 * The shieldbow client that enables you to interact with Riot Games' League of Legends API.
 * Also connects to the Data Dragon + Community Dragon CDNs.
 */
class Client {
    constructor(apiKey) {
        Object.defineProperty(this, "_cdnBase", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_versions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_initialized", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_patch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_locale", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_region", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cacheEnabled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_cacheRoot", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_champions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_items", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_runes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_summonerSpells", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_summoners", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_accounts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_leagues", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_matches", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_spectator", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_challenges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_clash", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_http", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_api", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_seasons", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_queues", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_maps", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_gameModes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_gameTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._cdnBase = 'https://ddragon.leagueoflegends.com/cdn/';
        this._versions = 'https://ddragon.leagueoflegends.com/api/versions.json';
        this._initialized = false;
        this._version = undefined;
        this._region = 'na';
        this._patch = undefined;
        this._locale = 'en_US';
        this._cacheEnabled = true;
        this._cacheRoot = 'data';
        this._seasons = [];
        this._queues = [];
        this._maps = [];
        this._gameModes = [];
        this._gameTypes = [];
        this._champions = new managers_1.ChampionManager(this, { enable: true, root: 'data' });
        this._items = new managers_1.ItemManager(this, { enable: true, root: 'data' });
        this._runes = new managers_1.RuneTreeManager(this, { enable: true, root: 'data' });
        this._summonerSpells = new managers_1.SummonerSpellManager(this, { enable: true, root: 'data' });
        this._summoners = new managers_1.SummonerManager(this);
        this._accounts = new managers_1.AccountManager(this);
        this._leagues = new managers_1.LeagueManager(this);
        this._matches = new managers_1.MatchManager(this);
        this._spectator = new managers_1.CurrentGameManager(this);
        this._clash = new managers_1.ClashManager(this);
        this._challenges = new managers_1.ChallengeManager(this);
        this._http = axios_1.default.create({ baseURL: this._cdnBase });
        this._api = new api_1.ApiHandler(apiKey);
    }
    /**
     * Initialize the client to prepare it for interacting with the API.
     * This can also be rerun if you want to configure anything and quickly fetch any required data.
     *
     * @param options - The client configuration.
     */
    async initialize(options) {
        // Parse the configuration
        const region = options?.region || 'na';
        this._region = region;
        const version = options?.version || undefined;
        this._version = version;
        this._patch = version !== undefined ? version.match(patchRegex).shift() : undefined;
        const language = options?.locale || undefined;
        if (language !== undefined)
            this._locale = language;
        if (typeof options?.cache === 'boolean')
            options.cache = { enable: options.cache };
        if (typeof options?.fetch === 'boolean')
            options.fetch = {
                champions: options?.fetch,
                items: options?.fetch,
                runes: options?.fetch,
                summonerSpells: options?.fetch
            };
        const enableCache = options?.cache?.enable ?? true;
        const cacheRoot = options?.cache?.localRoot || 'data';
        // Update the client configuration.
        if (version === undefined || language === undefined) {
            const response = await axios_1.default
                .get(region ? `https://ddragon.leagueoflegends.com/realms/${region}.json` : this._versions)
                .catch(() => { });
            if (response?.status !== 200)
                throw new Error('Unable to fetch data dragon version. Please confirm the region exists.');
            else {
                const result = response.data;
                if (Array.isArray(result)) {
                    this._version = version !== undefined ? version : result[0];
                    this._patch = this._version.match(patchRegex).shift();
                    this._locale = 'en_US';
                }
                else {
                    this._version = version !== undefined ? version : result.v;
                    this._locale = language !== undefined ? language : result.l;
                    this._patch = this._version.match(patchRegex).shift();
                }
            }
        }
        this._initialized = true;
        // Get the game constants from data dragon (this is static data)
        const seasonsResponse = await axios_1.default
            .get('https://static.developer.riotgames.com/docs/lol/seasons.json')
            .catch(() => { });
        const queuesResponse = await axios_1.default
            .get('https://static.developer.riotgames.com/docs/lol/queues.json')
            .catch(() => { });
        const mapsResponse = await axios_1.default.get('https://static.developer.riotgames.com/docs/lol/maps.json').catch(() => { });
        const gameModesResponse = await axios_1.default
            .get('https://static.developer.riotgames.com/docs/lol/gameModes.json')
            .catch(() => { });
        const gameTypesResponse = await axios_1.default
            .get('https://static.developer.riotgames.com/docs/lol/gameTypes.json')
            .catch(() => { });
        if (seasonsResponse?.status !== 200)
            throw new Error('Unable to fetch seasons static data from data dragon.');
        if (queuesResponse?.status !== 200)
            throw new Error('Unable to fetch queues static data from data dragon.');
        if (mapsResponse?.status !== 200)
            throw new Error('Unable to fetch maps static data from data dragon.');
        if (gameModesResponse?.status !== 200)
            throw new Error('Unable to fetch game modes static data from data dragon.');
        if (gameTypesResponse?.status !== 200)
            throw new Error('Unable to fetch game types static data from data dragon.');
        this._seasons = seasonsResponse.data;
        this._queues = queuesResponse.data.map((q) => ({
            ...q,
            notes: q.notes ?? undefined
        }));
        this._maps = mapsResponse.data.map((m) => ({
            ...m,
            image: this.cdnBase + this.version + `/img/map/map${m.mapId}.png`
        }));
        this._gameModes = gameModesResponse.data;
        this._gameTypes = gameTypesResponse.data;
        // Update the cache config
        if (this._cacheEnabled !== enableCache || this._cacheRoot !== cacheRoot) {
            this._cacheEnabled = enableCache;
            this._cacheRoot = cacheRoot;
            this._champions = new managers_1.ChampionManager(this, { enable: this._cacheEnabled, root: this._cacheRoot });
            this._items = new managers_1.ItemManager(this, { enable: this._cacheEnabled, root: this._cacheRoot });
            this._runes = new managers_1.RuneTreeManager(this, { enable: this._cacheEnabled, root: this._cacheRoot });
            this._summonerSpells = new managers_1.SummonerSpellManager(this, { enable: this._cacheEnabled, root: this._cacheRoot });
        }
        // Fetch the data and cache it for faster data retrieval.
        if (options?.fetch?.champions ?? false)
            await this.champions.fetchAll();
        if (options?.fetch?.items ?? false)
            await this.items.fetch('1001');
        if (options?.fetch?.runes ?? false)
            await this.runes.fetch('Domination');
        if (options?.fetch?.summonerSpells ?? false)
            await this.summonerSpells.fetch('SummonerFlash');
    }
    /**
     * Ensure that client was initialized
     */
    _ensureInitialized() {
        if (!this._initialized)
            throw new Error('Please initialize the client first.');
    }
    /**
     * The axios instance that handles all the CDN requests being made.
     */
    get http() {
        this._ensureInitialized();
        return this._http;
    }
    /**
     * The default API interactions handler used by the client.
     */
    get api() {
        this._ensureInitialized();
        return this._api;
    }
    /**
     * The league of legends region from which the data is to be fetched.
     */
    get region() {
        this._ensureInitialized();
        return this._region;
    }
    set region(region) {
        this._ensureInitialized();
        this._region = region;
    }
    /**
     * The Data Dragon CDN Base URL
     */
    get cdnBase() {
        this._ensureInitialized();
        return this._cdnBase;
    }
    /**
     * The default champions manager used by the client.
     */
    get champions() {
        this._ensureInitialized();
        return this._champions;
    }
    /**
     * The default items manager used by the client.
     */
    get items() {
        this._ensureInitialized();
        return this._items;
    }
    /**
     * The default runes manager used by the client.
     */
    get runes() {
        this._ensureInitialized();
        return this._runes;
    }
    /**
     * The default summoner spells manager used by the client.
     */
    get summonerSpells() {
        this._ensureInitialized();
        return this._summonerSpells;
    }
    /**
     * The default summoners manager used by the client.
     */
    get summoners() {
        this._ensureInitialized();
        return this._summoners;
    }
    /**
     * The default riot accounts manager used by the client.
     * This is mostly for internal usage. You may want to use {@link Client.summoners} instead.
     */
    get accounts() {
        this._ensureInitialized();
        return this._accounts;
    }
    /**
     * The default summoner competitive league data manager used by the client.
     *
     * Highly recommended using {@link Client.summoners} for a specific summoner's competitive info.
     *
     * Use this only if you want to query a list of users by rank-division.
     */
    get leagues() {
        this._ensureInitialized();
        return this._leagues;
    }
    /**
     * The default match manager used by the client.
     */
    get matches() {
        this._ensureInitialized();
        return this._matches;
    }
    /**
     * The default LOL challenges manager used by the client.
     */
    get challenges() {
        this._ensureInitialized();
        return this._challenges;
    }
    /**
     * The default live match manager used by the client.
     */
    get spectator() {
        this._ensureInitialized();
        return this._spectator;
    }
    /**
     * The default clash tournaments manager used by the client.
     */
    get clash() {
        this._ensureInitialized();
        return this._clash;
    }
    /**
     * Get the current status of the RIOT API.
     *
     * No type support for this (yet).
     */
    get status() {
        this._ensureInitialized();
        return new Promise(async (resolve, reject) => {
            const response = await this.api
                .makeApiRequest('/lol/status/v4/platform-data', {
                region: this.region,
                name: 'Get API Status',
                params: 'no params',
                regional: false
            })
                .catch(reject);
            if (response)
                resolve(response.data);
        });
    }
    /**
     * Update the locale in which the data is fetched.
     *
     * @param newLocale - The new locale to use for the future requests.
     * @param refetch - Whether to fetch all data dragon data in the new locale right away.
     */
    async updateLocale(newLocale, refetch = true) {
        this._ensureInitialized();
        this._locale = newLocale;
        if (refetch) {
            await this.champions.fetchAll();
            await this.items.fetch('1001');
            await this.runes.fetch('Domination');
            await this.summonerSpells.fetch('SummonerFlash');
        }
    }
    /**
     * Update the patch from which the data is fetched.
     *
     * NOTE: The patch must be 2 integers separated by a `.`.
     * For example: `10.11` or `12.9`.
     *
     * This should NOT be the data dragon version.
     *
     * @param patch - The new patch to use for the future requests.
     * @param refetch - Whether to fetch all data dragon data from the new patch right away.
     */
    async updatePatch(patch, refetch = true) {
        this._ensureInitialized();
        this._patch = patch;
        this._version = patch + '.1';
        if (refetch) {
            await this.champions.fetchAll();
            await this.items.fetch('1001');
            await this.runes.fetch('Domination');
            await this.summonerSpells.fetch('SummonerFlash');
        }
    }
    /**
     * The current Data Dragon CDN version.
     */
    get version() {
        this._ensureInitialized();
        return this._version;
    }
    /**
     * The patch of the game currently in use.
     *
     * Must be above 5.1 for proper functionality.
     */
    get patch() {
        this._ensureInitialized();
        return this._patch;
    }
    /**
     * Is this client initialized.
     */
    get initialized() {
        return this._initialized;
    }
    /**
     * The locale in which all the data is going to be fetched in.
     */
    get locale() {
        this._ensureInitialized();
        return this._locale;
    }
    set patch(patch) {
        this._ensureInitialized();
        this._patch = patch;
        this._version = patch + '.1';
    }
    /**
     * An array of all seasons and their respective IDs.
     */
    get seasons() {
        this._ensureInitialized();
        return this._seasons;
    }
    /**
     * An array of all queue types and their respective data.
     */
    get queues() {
        this._ensureInitialized();
        return this._queues;
    }
    /**
     * An array of all maps and their respective data.
     */
    get maps() {
        this._ensureInitialized();
        return this._maps;
    }
    /**
     * An array of all game modes and their respective data.
     */
    get gameModes() {
        this._ensureInitialized();
        return this._gameModes;
    }
    /**
     * An array of all game types and their respective data.
     */
    get gameTypes() {
        this._ensureInitialized();
        return this._gameTypes;
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map