"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiHandler = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const urls_1 = require("../util/urls");
const error_1 = require("./error");
const ratelimit_1 = require("./ratelimit");
/**
 * A class that handles API requests and rate limits for the RIOT API.
 */
class ApiHandler {
    /**
     * Create a new API handler.
     *
     * @param apiKey - your RIOT API key.
     */
    constructor(apiKey) {
        Object.defineProperty(this, "_http", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "limits", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._http = axios_1.default.create({
            headers: {
                'X-Riot-Token': apiKey
            }
        });
        this.limits = new ratelimit_1.Ratelimiter();
    }
    /**
     * Make an API request
     * @param url - The path to make the request to.
     * @param options - Some options to make the promise rejection messages more meaningful.
     */
    async makeApiRequest(url, options) {
        const request = `${options.name} (${options.params})`;
        return new Promise(async (resolve, reject) => {
            const requestLimit = this.limits.verify(options.region, options.name);
            if (!requestLimit.pass) {
                const mockResponse = {
                    data: undefined,
                    status: 429,
                    statusText: 'Too Many Requests',
                    headers: {},
                    config: {}
                };
                reject(new error_1.ApiError(mockResponse, request, `Retry in ${requestLimit.wait}ms.`));
            }
            else
                try {
                    const base = options.regional ? urls_1.regionalURLs[options.region] : urls_1.apiBaseURLs[options.region];
                    const response = await this._http.get(base + url);
                    this.limits.update(options.region, response, options.name);
                    if (response.status === 200)
                        resolve(response);
                }
                catch (error) {
                    const { response } = error;
                    if (response)
                        this.limits.update(options.region, response, options.name);
                    if (response)
                        reject(new error_1.ApiError(response, request));
                    else
                        reject(error);
                }
        });
    }
}
exports.ApiHandler = ApiHandler;
//# sourceMappingURL=handler.js.map